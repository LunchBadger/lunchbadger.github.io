[
{
	"uri": "https://docs.lunchbadger.com/about/",
	"title": "About",
	"tags": [],
	"description": "",
	"content": " What is LunchBadger? LunchBadger is a microservices platform that developers and devops engineers can use to build microservices, deploy them to any cloud, and expose them as APIs for consumption.\nWhy would I want to use LunchBadger? Time. You\u0026rsquo;ll save massive amounts of time trying to attain the benefits of a microservices architecture. LunchBadger provides the following to repeatedly save you time:\n best practices for microservices built into the tool code scaffolding and built-in boilerplates automated real time deployment to the cloud(s) of your choice visual orchestration and wiring of microservices to an API gateway, data sources, and more  How does LunchBadger Work? LunchBadger is driven by a GUI known as the Canvas. The Canvas guides user in the process of building, deploying, and managing microservices and exposing them as APIs.\nLunchBadger utilizes the best of breed open source projects for easy adoption, constant innovation and specialization of what each component brings to putting together a holistic microservices platform.\nSource-level access to these components provides opportunities in transparent customization and support along with community driven innovation. Here are the main projects used behind the scenes and integrated into LunchBadger:\n Express Gateway - an API gateway to expose microservices by defining them as service endpoints and exposing them as API endpoints externally LoopBackJS - a Node.js based framework that lets you create microservices using a model driven approach Serverless - a cloud agnostic framework that Acts as an adapter to serverless (a.k.a Function-as-a-Service (FaaS)) platforms. Kubeless - A Kubernetes native serverless engine that allows you to write functions in many supported languages Kubernetes - a container orchestrator that runs in any cloud that deploys microservices as they are built in LunchBadger ReactJS - a GUI framework that allows you to extend and build on top of LunchBadger\u0026rsquo;s visual interface  Interested in our open source project, Express Gateway? If youâ€™d like to contribute, please see our Github website repo or you can join our Community on Gitter. Commercial Support options are also available for Express Gateway.\nNeed Support? Now that you\u0026rsquo;re armed with the basics of how to use LunchBadger, have fun! Feel free to play around with Entities on the Canvas and direct any questions to your LunchBadger Support Team via the chat window on the lower right or drop us an email at hello@lunchbadger.com.\n"
},
{
	"uri": "https://docs.lunchbadger.com/basics/entity-palette/connectors/",
	"title": "Connectors",
	"tags": [],
	"description": "",
	"content": "To create a Connector click on the connector icon on the entity palette:   a sub-menu of different connector types will appear:\nConnectors are prebuilt libraries that allow you to utlize a wide array of popular data sources and services. At this time, Connectors can be only directly utilized by Models by connecting the Connector port to the left Model port.\nEach connector entity will come with its own set of properties specific for that type of connection.\nConnectors in LunchBadger are based on LoopBack data sources and their corresponding connectors\n LunchBadger comes with the following connectors:\n Memory REST SOAP MongoDB Redis MySQL PostgreSQL Ethereum Salesforce  LunchBadger provides a graphical interface for configuring the LoopBack based connectors listed above. Any LoopBack connector can be utilized by LunchBadger. There are many, many more LoopBack connectors that can be utilized by LunchBadger even if there isn\u0026rsquo;t a supporting GUI entry in Connectors entity types! Check out the LoopBack Awesome List for more connectors.\n "
},
{
	"uri": "https://docs.lunchbadger.com/basics/canvas/",
	"title": "Canvas",
	"tags": [],
	"description": "",
	"content": " The LunchBadger platform Canvas is a single pane of glass where you can design, build and create your microservices and APIs.\n The Canvas is broken up into a few easy parts to understand:\n entity palettte quadrants panels  Entity Palette The left most toolbar is called the Entity Palette. Each icon in the palette represents a different entity that you can create. The entity palette is divided up into different entity types.\nSome entities are used when you are developing your microservcies and integrating to existing data and application. Others are used when you want to expose microservices as APIs and secure them through an API gateway. More Details: Entity Palette\nQuadrants The columns that take up most of the area witihn the Canvas with a gray header are called Quadrants. Quadrants represent different tiers within your microservices application. They are designed to help you logically classify the different parts of your application in a microservices architecture. Having the logical model of your microservices defined makes it easier to scale individual microservices accordingly within the Kubernetes runtime.\nBackend The backend quadrant represents where you data and services exist and or persisted. Microservices can be built on top of existing legacy applications and or data.\nThere\u0026rsquo;s no need to throw away your old applications as you move into a microservices architecture. LunchBadger has tooling to help you create a new layer of microservices on top of your old applications. This will allow you to build entirely new microservices alongside microservices that sit as a layer on top of legacy.\n LunchBadger utilizes the same tooling to connect to new data sources where you want to persist data utilized with new microserivces.\nExample:\n You have data in MySQL that exists as rows and tables and you want to create a set of microservices that represent that data. A MySQL connector can be created in the backend quadrant and represents a connection to MySQL as a legacy data source.\n Example:\n You are creating a new microservice that handles payments. The microservices requires each payment performed to be recorded with transaction details as a JSON object. A MongoDB connector can be created in the backend quadrant that represents the connection to new MongoDB instance that will store the new transaction data.\n Private The private quadrant represents all business functionality within your application. This quadrant contains all models, service endpoints and functions in your system. They are not exposed publically, but can communicate with each other. In LunchBadger communication with external services is done through a Gateway\nExample:\n You have a legacy SOAP service that represents a customer. The customer SOAP object has 100 properties. You want to surface a new credit application API backed by a model based microservice that only requires 10 of the 100 fields that are minimally needed for a new customer applying for credit. A customer microsevice model can be created with the 10 fields that are required connecte to an instance of the SOAP connector in the backend quadrant pointed to the legacy SOAP service.\n Example:\n You have a function that calculates and suggests a recommended price for a particular car given an historical list of average prices and dates paid by past buyers for the car. A SuggestedPriceCalculator function can be deployed and written in Node, Python and other languages to take the list of average prices and dates and do a weighted calcuation of a price to look for when shopping for a car.\n Example:\n You want to surface a uniform API that powers a Yelp like application that shows all restaurants near your user. The list of restaurants and their addresses are handled by a Restaurant model based microservice and the geolocation lookup is done by a 3rd party API - Google Maps. A Service Endpoint can be created to point to the Google Maps URL to pass in geolocation coordinates to do a lookup calculation for distance between the user and each of the restaurants.\n Gateway The gateway quadrant is a dividing line between what is public facing and consumed by consumers through an API and what is private and managed by producers as a set of microservices connected to backend systems. The only entity created within this quadrant are gateways. Gateway entities represent created and deployed instances of Express Gateway. These instances act as an API Gateway within your application. Gateways expose HTTP based API endpoints, provide policy based quality of services (like routing, authentication, authorization, rate-limiting etc.) and proxy in front of entities within the private quadrant.\nExample:\n You have a couple of model based microservices that act as REST resources - cart, catalog, user. Each of these models can be wired up to a gateway entity in this quadrant and be exposed as REST API endpoint by the gateway. The gateway in this qudadrant can be configured with policies to proxy to these backned models and secure them with authentication and authorization policies like key authorization.\n Public The public quadrant contains entities that are exposed and directly visible to any consumer of your application. Consumers can interact directly with these entities. The public quadrant contains API endpoint entities exposed by gateways in the gateway quadrant. API endpoints are HTTP based URLs that can be called directly by a client external to your application.\nExample:\n You have a domain and URL for exposing a REST API for cart as http://www.petstore.com/api/v1/cart. This URL is exposed as an API endpoint in the public quadrant.\n Panels Panels are different views within LunchBadger. Panels are featured alongside other icons on the top right toolbar in the header within the user interface. Each panel slides down the quadrants from sight partially to review a new panel of controls. The Settings Panel featured by the cogs icon is the only panel available at this time.\n"
},
{
	"uri": "https://docs.lunchbadger.com/basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": " Basics Learn the basics to understand key concepts to get started and be productive building microservices and APIs.\n"
},
{
	"uri": "https://docs.lunchbadger.com/basics/entity-palette/models/",
	"title": "Models",
	"tags": [],
	"description": "",
	"content": " To create a Model click on the model icon on the entity palette:   The Model Entity is a graphical representation of a LoopBack Model. Models can have properties you\u0026rsquo;d like to expose from data sources and services through Connectors.\nIf you\u0026rsquo;re familiar with the Model-View-Controller pattern, Models in LunchBadger are exactly the M in MVC. For folks who are more backend, a model is very much like a data access object.\n All Models are Node.js JavaScript functions. Models have the following basic built in functionality:\n properties read and or write data through Connectors. scaffold a REST representation dynamically based on its definition  Quick Edit a Model After creating a Model in the private quadrant, you\u0026rsquo;ll be ready to enter properties with a property name and property type while in Quick Edit mode. To enter quick edit mode for a Model, click the pencil Quick Edit icon on the Model, by hovering over its title bar to display the context menu.\nModel Details Models have advanced functionality that can be access through its Details. To access a Model\u0026rsquo;s Details, hover over the title bar to display the context menuu and chose the ellipses icon.\nModels details expose things like relationships, connector metadata, user defined fields, and other advanced functionality.\nBecause Models are really nothing more than JavaScript functions, a code editor is also provided in Model Details to script anything that doesn\u0026rsquo;t have a GUI representation including custom logic.\nLunchBadger provides a GUI experience to help you get started and gives you have complete control once you become a more advanced user. For more information on advanced features and customizing Models programatically through code refer to the LoopBack model documentation.\nAuto REST Generation Once a Model is connected to a Connector it will automatically generate a REST interface and corresponding Swagger/OpenAPIv2 specification and with fully functional endpoints.\nThe REST Generation is not only automatic by dynamically updated as you edit your Model.\n Click on the gear icon in the right hand toolbar to actiave the Settings Panel. Visit the URL listed for the API Explorer to try out the REST API. "
},
{
	"uri": "https://docs.lunchbadger.com/basics/entity-palette/",
	"title": "Entity Palette",
	"tags": [],
	"description": "",
	"content": " The entity palette let\u0026rsquo;s you create new entities onto the Canvas by simply clicking on the icon. Entities are automatically created and placed into their corresponding Quadrants.\nEntity Types:\n Microservice Integration Microservice Composition API Management  Microservice Integration Entities If you have existing data or services that you want to leverage in your new microservies application, you can use these entities to leverage them.\nIntegration entities include:\n Connectors - let\u0026rsquo;s you connect to data sources and existing services so that you can take advantage of them in a microservice built with a model  Model entities can be connected to data sources and services through a Connector.\n Microservice Composition Entities Composition entities let you build new microserivces with existing data and legacy applications or start greenfield often utilizing Connectors.\nComposition entities include:\n Models - a prebuilt JavaScript function that represents an object with properties that can utilize Connectors Functions - a serverelss function that can be written in Node.js, Go, Python, Ruby and other supported languages.  API Management Entities API Management entities include:\n Gateways - microgateways that function as an API Gateway that secures and manages your microservices and exposes them as consumable APIs Service Endpoints - any internal endpoint that a Gateway proxies API Endpoints - externalized endpoints that are exposed by the API Gateway to be consumed as an API by a client  Everything proxied by a Gateway is technically considered a Service Endpoint. A Service Endpoint is really nothing more than a referenced proxied URL. Models and Functions can be proxied by a Gateway and are seen as service endpoints to the Gateway because they automatically have HTTP based URLs assigned to them as microservices.\n "
},
{
	"uri": "https://docs.lunchbadger.com/basics/git-access/",
	"title": "Git Access",
	"tags": [],
	"description": "",
	"content": "LunchBadger provide 2 GIT repositories containing your code. First is the repo for code containing all models. git clone git@git.lunchbadger.com:customer-{your user id}/dev.git The Second contains code of functions git clone git@git.lunchbadger.com:customer-{your user id}/functions.git\nTo access the repos you need to upload your public SSH key first. Press setting cog icon in the top right corner of the App.\nYou should see settings page; scroll down to see: Note the git URL is shown in Access via Git section\nPress + icon to add new SSH key To copy your public SSH key into clipboard use\npbcopy \u0026lt; ~/.ssh/id_rsa.pub  Paste content into Key field and add some label to identify the key in future and press the Uploadbutton\nnow just git clone ...\n"
},
{
	"uri": "https://docs.lunchbadger.com/basics/entity-palette/functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": " To create a Function click on the function icon on the entity palette:   The Function entity represents a serverless function that runs in the Kubeless serverless engine in your Kubernetes cluster.\nServerless functions are self contained pieces of functionality that run when triggered.\nWhen you create a new Function, you select the supported language to be used within the function and specify a name. Once you create a function, it is automatically deployed.\nWhat\u0026rsquo;s the difference between Models and Functions? Both Models and Functions are functions. Models are Node.js only and have built in capabilites provided by the LoopBack framework. Functions are barebone functions that can be written in a number of supported languages through the Kubeless engine.\n Function Details To enter code into the body of a Function, go to the Function Details by hovering over the title bar on the Function entity and click the ellipses icon on the context menu.\nA code editor similar to the one provided in Model Details will be presented.\nNode.js Example:\n handler.js is the file with main entry point. you can create another files and reference them\npackage.json contains node.js package dependencies. LunchBadger will install them during function launch.\n All LunchBadger Function code is stored in its own git repository. See Git Access for details.\n"
},
{
	"uri": "https://docs.lunchbadger.com/demo/",
	"title": "Demo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.lunchbadger.com/basics/entity-palette/gateways/",
	"title": "Gateways",
	"tags": [],
	"description": "",
	"content": " To create a Gateway click on the function icon on the entity palette:   The Gateway entity represents an instance of Express Gateway. Express Gateway is a microservices API Gateway.\nIn LunchBadger, Gateways are used to provide API management functionality for your microservices application. A Gateway expose private and internal microservices publicly through APIs.\nHow Gateways Work Gateways in LunchBadger are used to proxy to microservice entities in the private quadrant and manage and expose them as APIs as API endpoints in the public quadrant.\nEach Gateway consists of one or more Pipelines. A Pipeline is a set of policies. Each Pipeline has connection ports to its left an right hand side.\nThe Models, Functions and Service Endpoints are proxied entities connected to the Gateway\u0026rsquo;s Pipeline from the left hand side.\nA corresponding API Endpoint in the public quadrant is created and connected to the right hand side of the Pipeline.\nGateways in LunchBadger are powered by Express Gateway. More details on Express Gateway can be found in the Express Gateway Documentation\n Walkthrough Example A complete example microservice application is displayed in the LunchBadger Canvas depicted above.\n A TemperatureAPIEndpoint exists in the public quadrant. This API Endpoint is publicly accessible through HTTP. You can cURL this endpoint through its URL.\ncURL http://\u0026lt;root url\u0026gt;/api/temperature   cURLing the API Endpoint sends the request to the Pipeline within the Gateway that is present in the Gateway quadrant.\n The Pipeline contains a Proxy Policy which routes the request to the entity connected on its left hand port.\n The Temperature Model is connected to the left hand port of the Pipeline and receives the request because of the Proxy policy within the Pipeline.\n The Temperature Model is connected to the Memory Connector and the API Request to GET data.\n The Temperature Model grabs temperature data from the Memory Connector populates a Temperature object through its Model definition with its properties and then sends that representation back through as the response.\n  Accessing Gateway Instances API Endpoints hosted by a Gateway iare accessible via URL and path(s) specified in the API Endpoint.\nExample:\nThe CarAPIEndpoint depicted above is accessible through the URL - http://gateway-al2-dev.staging.lunchbadger.io/api/car\nURLs for API Endpoints follow the convention listed below:\nhttp://\u0026lt;gateway root url\u0026gt;.lunchbadger.io/\u0026lt;api endpoint path\u0026gt;\nConsumer Management Gateways have a built in consumer management system as a reference implementation for identity management. The purpose of consumer management is to define API Consumers that are known and managed by the Gateway.\nClick on the man with the suitecase icon on the Gateway context toolbar to access Consumer Management\nAPI Consumers An API Consumer is one of the following:\n User Application (App)  For more information on the Consumer Management capabilities within the Gateway, see the Consumer Management documentation on Express Gateway.\n To create Users,Apps, and Scopes press the plus + icon.\nCredentials Every API Consumer has their own set of Credentials. There are several types of Credentials supported by the Gateway in LunchBadger:\n basic authorization key authorization OAuth2  To create Credentials click on row of the User or App.\nFor more information on the Credentials supported bythe Gateway, see the Credential Management documentation on Express Gateway.\n Please refer to Express Gateway Consumer Management for more information\n"
},
{
	"uri": "https://docs.lunchbadger.com/basics/entity-palette/service-endpoints/",
	"title": "Service Endpoints",
	"tags": [],
	"description": "",
	"content": "Used as Express Gateway API Endpoints for clients connecting to Gateway Entities.\n"
},
{
	"uri": "https://docs.lunchbadger.com/basics/entity-palette/api-endpoints/",
	"title": "API Endpoints",
	"tags": [],
	"description": "",
	"content": "Used as Express Gateway API Endpoints for clients connecting to Gateway Entities.\n"
},
{
	"uri": "https://docs.lunchbadger.com/",
	"title": "HOME",
	"tags": [],
	"description": "",
	"content": " Overview Welcome to LunchBadger Documentation! LunchBadger takes the idea behind microserivces and APIs and makes it concrete and real.\nWith LunchBadger it\u0026rsquo;s easy to\u0026hellip;\n develop microservices - starting with existing applications and data or with something completely greenfield. build and deploy your microservices into the cloud in real time expose your microservices as APIs consumable by other applications or clients internally or externally  If you haven\u0026rsquo;t already - please check out the LunchBadger Quickstart to see how you can get up and running with microservices and APIs in no time.\n"
},
{
	"uri": "https://docs.lunchbadger.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.lunchbadger.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]